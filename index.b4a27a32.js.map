{"mappings":"YAqBO,SAASA,EAAgBC,GAC5B,IAIMC,EAAO,IAAIC,gBAAgB,CAC7BC,QAHW,wEAIXC,UAAUJ,IAGlB,OAAOK,MAAM,GAAeC,OATN,+BASG,KAAeA,OARnB,gBAQgB,KAAUA,OAAPL,IAAUM,MAAK,SAACC,GACpD,IAAKA,EAASC,GACd,MAAM,IAAIC,MAAM,kBAEhB,OAAOF,EAASG,M,ICnCb,SAASC,EAAaC,GACzB,IAAMC,EAAQD,EAAK,GAAZC,IAC+BC,EAAAF,EAAK,GAAGG,OAAO,GAA/CC,EAAgCF,EAAhCE,KAAMC,EAA0BH,EAA1BG,YAAaC,EAAaJ,EAAbI,YAE7B,MAAO,qCACkBb,OAAbQ,EAAI,WAENR,OAFeW,EAAK,oEAGrBX,OADCW,EAAK,kBAEyCX,OAD/CY,EAAY,gEAC+CZ,OAAZa,EAAY,uB,CCJpE,IFCUlB,EEDJmB,EAAO,CACTC,YAAaC,SAASC,cAAc,iBACpCC,OAAQF,SAASC,cAAc,WAC/BE,MAAOH,SAASC,cAAc,UAC9BG,QAASJ,SAASC,cAAc,cAqCgL,SAA3MI,EAAaC,GAClBR,EAAKK,MAAMI,MAAMC,QAAS,OAC1BV,EAAKI,OAAOK,MAAMC,QAAS,QAC3BV,EAAKM,QAAQK,UAAW,GAGxBhC,EAFgB6B,EAAMI,OAAOC,OAGxB1B,MAAK,SAACM,GAEwEO,EAA1EM,QAAQK,UAAYnB,EAAaC,E,IAGrCqB,OAAM,SAACC,GAERf,EAAKK,MAAMI,MAAMC,QAAS,QAC1BM,QAAQC,IAAIF,E,IAEXG,SAAQ,WACLlB,EAAKI,OAAOK,MAAMC,QAAS,OAC3BV,EAAKM,QAAQG,MAAMC,QAAS,O,IAnDoDV,EAAvFC,YAAYQ,MAAMC,QAAS,OAChCV,EAAKM,QAAQG,MAAMC,QAAS,OAC5BV,EAAKI,OAAOK,MAAMC,QAAS,QAC3BV,EAAKK,MAAMI,MAAMC,QAAS,QFXhB7B,EAAO,IAAIC,gBAAgB,CAC7BC,QAHW,0EAMZE,MAAM,GAAeC,OARN,+BAQG,KAAeA,OAPnB,SAOgB,KAAUA,OAAPL,IAAUM,MAAK,SAACC,GACpD,IAAKA,EAASC,GACV,MAAM,IAAIC,MAAM,kBAEpB,OAAOF,EAASG,M,KESfJ,MAAK,SAACS,GACHI,EAAKC,YAAYU,UAAYf,EAAOuB,KAAI,SAACC,G,MAAQ,kBAA+BlC,OAAbkC,EAAMC,GAAG,MAAenC,OAAXkC,EAAMvB,KAAK,Y,IAC1FyB,KAAK,IAGmCtB,EAApCC,YAAYsB,iBAAiB,SAAUhB,E,IAG/CO,OAAM,SAACC,GAEiLf,EAApLK,MAAMI,MAAMC,QAAS,QAC1BM,QAAQC,IAAIF,E,IAEXG,SAAQ,WACLlB,EAAKC,YAAYQ,MAAMC,QAAS,QAChCV,EAAKI,OAAOK,MAAMC,QAAS,M","sources":["src/cat-api.js","src/markup.js","src/index.js"],"sourcesContent":["//Напиши функцію fetchBreeds(), яка виконує HTTP-запит і повертає проміс із масивом порід - результатом запиту. Винеси її у файл cat-api.js та зроби іменований експорт.\nexport function fetchBreeds() {\n    const BASE_URL  = \"https://api.thecatapi.com/v1\";\n    const ENDPOINT = \"breeds\"\n    const APY_KEY =\"live_KhQV1oKIS4BCvrcPDeozPUb3E9SMkjS0ykizMr5iBCwxr7OS8E0iDtuzHjzD1OGJ\"\n\n    const params=new URLSearchParams({\n        api_key:APY_KEY,\n    })\n\nreturn fetch(`${BASE_URL}/${ENDPOINT}?${params}`).then((response)=>{\n    if (!response.ok) {\n        throw new Errow(\"404 not found!\");\n    } \n    return response.json(); \n    })\n\n}\n\n\n//Напиши функцію fetchCatByBreed(breedId), яка очікує ідентифікатор породи, робить HTTP-запит і повертає проміс із даними про кота - результатом запиту. Винеси її у файл cat-api.js і зроби іменований експорт.\nexport function fetchCatByBreed(breedId) {\n    const BASE_URL  = \"https://api.thecatapi.com/v1\";\n    const ENDPOINT = \"images/search\"\n    const APY_KEY =\"live_KhQV1oKIS4BCvrcPDeozPUb3E9SMkjS0ykizMr5iBCwxr7OS8E0iDtuzHjzD1OGJ\"\n\n    const params=new URLSearchParams({\n        api_key:APY_KEY,\n        breed_ids:breedId,\n    })\n\nreturn fetch(`${BASE_URL}/${ENDPOINT}?${params}`).then((response)=>{\n    if (!response.ok) {\n    throw new Errow(\"404 not found!\");\n    } \n    return response.json(); \n})\n}\n\n\n","export function createMarkup(data) {\n    const {url} = data[0]; //деструктуризуємо властивість url  обєкта в масиві breeds. Масив містять лише 1 обєкт без імені, тому до нього звертаємося під індексом 0. \n    const{name, description, temperament}=data[0].breeds[0]; //деструктуризуємо властивості обєкта в масиві breeds, який у свою чергу знаходиться в масиві data. Обидва масиви містять лише по одному обєкту, тому до них звертаємося під індексом [0].\n\nreturn `<div class=\"cat-card\">\n<img src=\"${url}\" alt=\"${name} width=\"600\" height=\"400>\n<div class=\"cat-card-info\">\n    <h1>${name}</h1>\n    <p>${description}</p>\n    <p><span class=\"temperament\">Temperament: </span> ${temperament}</p>\n</div>\n</div>` \n}     ","//................HTTP-запити...........................................\n\nimport { fetchBreeds, fetchCatByBreed } from \"./cat-api.js\";\nimport { createMarkup } from \"./markup.js\"\n\nconst refs = {\n    breedSelect: document.querySelector(\".breed-select\"),\n    loader: document.querySelector(\".loader\"),\n    error: document.querySelector(\".error\"),\n    catInfo: document.querySelector(\".cat-info\"),\n}\n\n\n//Поки відбувається будь-який HTTP-запит, необхідно показувати завантажувач - елемент p.loader. А всі інші елементи приховати:\nrefs.breedSelect.style.display= \"none\";\nrefs.catInfo.style.display= \"none\";\nrefs.loader.style.display= \"block\";\nrefs.error.style.display= \"none\";\n\n\n\n//Під час завантаження сторінки має виконуватися HTTP-запит за колекцією порід - тобто буде викликатися функція fetchBreeds. Під час обробки її результату (масиву breeds), ми map-ємо цей масив (з кожного обєкту масиву  витягуємо необхідні властивості (id, name) і наповнюємо (за доп.innerHTML) ними опції breedSelect так, щоб value опції містило id породи, а в інтерфейсі користувачеві відображалася назва породи:\nfetchBreeds()\n    .then((breeds)=>{\n        refs.breedSelect.innerHTML = breeds.map((breed)=>`<option value=\"${breed.id}\">${breed.name}</option>`)\n        .join(\"\")\n        \n        //Після того як ми наповнили breedSelect, додаємо слухача  події change \n        refs.breedSelect.addEventListener(\"change\", handleSelect);\n    })\n\n    .catch((err)=>{\n    //Якщо у користувача сталася помилка під час будь-якого HTTP-запиту, наприклад, впала мережа, була втрата пакетів тощо, тобто проміс було відхилено, необхідно відобразити елемент p.error, а при кожному наступному запиті приховувати його. \n    refs.error.style.display= \"block\";\n    console.log(err);\n    })\n    .finally(()=>{\n        refs.breedSelect.style.display= \"block\";\n        refs.loader.style.display= \"none\";\n        \n    }\n    );\n\n\n    \n//Оголошення функції для слухача події \"change\" на breedSelect. Коли користувач обирає якусь опцію в селекті, необхідно виконувати запит за повною інформацією про кота,  тобто при події change в викливається функція fetchCatByBreed, якій для параметра рядка запиту breed_ids передається ідентифікатор породи breedId.\nfunction handleSelect(event) {\n    refs.error.style.display= \"none\";\n    refs.loader.style.display= \"block\";\n    refs.catInfo.innerHTML= \"\"; //очищаємо картку,щоб поки буде робитися новий запит, старої картки вже не було на екрані\n    const breedId = event.target.value; //ідентифікатор породи беремо з вибраної опції селекту breedSelect, на якому висить слухач події (у опцій value=breed.id).\n    \n    fetchCatByBreed(breedId)\n        .then((data)=>{\n        //Результат (data) виклику фунції fetchCatByBreed під час обробки записуємо в catInfo (зробивши розмітку за допомогою функції createMarkup)\n        refs.catInfo.innerHTML = createMarkup(data);\n        })\n\n        .catch((err)=>{\n        //Якщо у користувача сталася помилка під час будь-якого HTTP-запиту, наприклад, впала мережа, була втрата пакетів тощо, тобто проміс було відхилено, необхідно відобразити елемент p.error, а при кожному наступному запиті приховувати його. \n        refs.error.style.display= \"block\";\n        console.log(err);\n        })\n        .finally(()=>{\n            refs.loader.style.display= \"none\";\n            refs.catInfo.style.display= \"block\";           \n        })\n}\n\n\n\n"],"names":["$ae0c329fb0fb36dc$export$57b7d3a597416aa2","breedId","params","URLSearchParams","api_key","breed_ids","fetch","concat","then","response","ok","Errow","json","$ed6c7ef50a59e439$export$24783e9f3a24abe4","data","url","ref","breeds","name","description","temperament","$b8f9b7833fa37166$var$refs","breedSelect","document","querySelector","loader","error","catInfo","$b8f9b7833fa37166$var$handleSelect","event","style","display","innerHTML","target","value","catch","err","console","log","finally","map","breed","id","join","addEventListener"],"version":3,"file":"index.b4a27a32.js.map"}